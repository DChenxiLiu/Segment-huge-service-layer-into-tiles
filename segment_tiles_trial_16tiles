import arcpy
import os

project = arcpy.mp.ArcGISProject("CURRENT")
# layer_name = "Imagery_2024"  
output_dir = r"C:\Users\c72liu\OneDrive - University of Waterloo\Projects\WR_tiles\test_tiles" ##change to match your output directory
tile_size = 100  
spatial_ref = arcpy.SpatialReference(26917)  # Change to match your projection

# Create output folder
os.makedirs(output_dir, exist_ok=True)

# Get the active map
map_ = project.activeMap
if not map_:
    map_ = project.listMaps()[0]

print(f"Working with map: '{map_.name}'")

# Directly get the Imagery_2024 layer
target_layer_name = "Imagery_2024"
all_layers = map_.listLayers()

# Find the specific layer by name
layer = None
for lyr in all_layers:
    if lyr.name == target_layer_name:
        layer = lyr
        break

if layer:
    print(f"Found and using layer: '{layer.name}'")
else:
    print(f"Error: Could not find layer '{target_layer_name}' in the map.")
    print("Available layers:")
    for lyr in all_layers:
        print(f"  - {lyr.name}")
    exit(1)

# Get extent of the layer
desc = arcpy.Describe(layer)
extent = desc.extent

print(f"Layer extent: {extent.XMin}, {extent.YMin}, {extent.XMax}, {extent.YMax}")

# For image services, let's check the pixel size to calculate safe tile dimensions
try:
    # Get raster properties to understand pixel size
    cell_size_x = desc.meanCellWidth if hasattr(desc, 'meanCellWidth') else 1.0
    cell_size_y = desc.meanCellHeight if hasattr(desc, 'meanCellHeight') else 1.0
    print(f"Estimated cell size: {cell_size_x} x {cell_size_y} meters")
    
    # Calculate how many pixels our tile will be
    pixels_x = tile_size / cell_size_x
    pixels_y = tile_size / cell_size_y
    print(f"Tile size in pixels: {pixels_x:.0f} x {pixels_y:.0f}")
    
    # Be very conservative with server limits - use much smaller values
    max_safe_pixels = 1000  # Very conservative limit
    if pixels_x > max_safe_pixels or pixels_y > max_safe_pixels:
        # Adjust tile size to be very small
        tile_size = max_safe_pixels * min(cell_size_x, cell_size_y)
        pixels_x = tile_size / cell_size_x
        pixels_y = tile_size / cell_size_y
        print(f"Adjusted tile size to {tile_size:.0f} meters ({pixels_x:.0f}x{pixels_y:.0f} pixels)")
        
except Exception as e:
    print(f"Could not determine cell size: {e}")
    print("Using very small default tile size for safety")
    tile_size = 50  # Even smaller fallback

print(f"Final tile size: {tile_size} meters")

# Calculate tile grid (8x8 tiles for larger coverage)
xmin, ymin, xmax, ymax = extent.XMin, extent.YMin, extent.XMax, extent.YMax
center_x = (xmin + xmax) / 2
center_y = (ymin + ymax) / 2

# Create grid of tiles
grid_size = 2  # 2x2 grid for simplicity, can be adjusted
half_grid = grid_size // 2

print(f"Creating {grid_size}x{grid_size} grid ({grid_size*grid_size} tiles total)")
print(f"Each tile: {tile_size}m x {tile_size}m")
print(f"Total coverage: {grid_size*tile_size}m x {grid_size*tile_size}m")

offsets = []
for row in range(grid_size):
    for col in range(grid_size):
        # Calculate offset from center
        dx = (col - half_grid + 0.5) * tile_size
        dy = (row - half_grid + 0.5) * tile_size
        offsets.append((dx, dy))

print(f"Generated {len(offsets)} tile positions")

for idx, (dx, dy) in enumerate(offsets):
    x0 = center_x + dx
    x1 = x0 + tile_size
    y0 = center_y + dy
    y1 = y0 + tile_size
    
    # Calculate row and column for better naming
    row = idx // grid_size + 1
    col = idx % grid_size + 1
    out_path = os.path.join(output_dir, f"tile_r{row:02d}_c{col:02d}.tif")
    
    print(f"Exporting tile {idx+1}/{len(offsets)} (Row {row}, Col {col}) to {os.path.basename(out_path)} ...")
    print(f"  Extent: {x0:.2f}, {y0:.2f}, {x1:.2f}, {y1:.2f}")
    
    # Create extent string
    extent_str = f"{x0} {y0} {x1} {y1}"

    try:
        # Clip raster using extent
        arcpy.management.Clip(
            in_raster=layer,
            rectangle=extent_str,
            out_raster=out_path,
            nodata_value="-9999",
            clipping_geometry="NONE",
            maintain_clipping_extent="MAINTAIN_EXTENT"
        )
        print(f"  ✓ Successfully exported tile {idx+1}")
    except Exception as e:
        print(f"  ✗ Error exporting tile {idx+1}: {e}")
        print(f"  Try reducing tile_size further (current: {tile_size} meters)")
        continue

print("\nTile export complete!")

# Count successfully exported tiles
exported_tiles = []
for idx in range(len(offsets)):
    row = idx // grid_size + 1
    col = idx % grid_size + 1
    tile_path = os.path.join(output_dir, f"tile_r{row:02d}_c{col:02d}.tif")
    if os.path.exists(tile_path):
        exported_tiles.append(tile_path)

print("\n=== SUMMARY ===")
print(f"Tiles exported: {len(exported_tiles)}/{len(offsets)}")
print(f"Output directory: {output_dir}")
print("Files created:")
if len(exported_tiles) > 0:
    print(f"  - Individual tiles: tile_r01_c01.tif through tile_r{grid_size:02d}_c{grid_size:02d}.tif")
    print(f"  - Total coverage: {grid_size*tile_size}m x {grid_size*tile_size}m")
else:
    print("  - No tiles were successfully exported")